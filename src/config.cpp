/*
 * This file is part of MCalx, a simple GPL matrix calculator
 * (c) 2015  Daniel R. Ome
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *
 */

#include <sys/stat.h>
#include <unistd.h>
#include <string>
#include <iostream>
#include <fstream>
#include <map>
#include "config.h"

using namespace std;

/* constants */
const char *      fdelimeter = ";|{Tab}|{space}";
const map <int, char> fd_def = { {0, ';'}, {1, '\t'}, {2, ' '} };

const char *      tdelimeter = "\"|'";
const map <int, char> td_def = { {0, '"'}, {1, '\''} };

char const * cfgpath = "/.config/mcalx/";
const char *
msgWarning = "#\n# PLEASE, DO NOT EDIT THIS FILE\n#\n# It is automatically generated by mcalx.\n# Any manual changes will be rewritten.\n#\n";

const datacfg dt_init = { 3, 3, 2, 3, 3, 2, 2, 0, 0 };

bool datacfg::operator == (const datacfg &b) const {
	   return ( rowMatrixA == b.rowMatrixA && colMatrixA == b.colMatrixA &&
	   	   	   	   precisionA == b.precisionA && rowMatrixB == b.rowMatrixB &&
	   	   	   	   colMatrixB == b.colMatrixB && precisionB == b.precisionB &&
	   	   	   	   precisionC == b.precisionC && fdel == b.fdel &&
	   	   	   	   tdel == b.tdel );
}

/* code */

string set_filename() {
   const char* home;
   const char* xdgconfighome;
   string   xdgconfigmcalx;
   string   homemcalx;
   string   filenamemcalx;

   if ( (home = getenv( "HOME" )) == NULL ) {
      home = "";
      homemcalx.assign( "/" );
      filenamemcalx.assign( "/" );
      xdgconfigmcalx.assign( "/" );
   }

   if ( (xdgconfighome = getenv( "XDG_CONFIG_HOME" )) == NULL ) {
      homemcalx.append( string(home) + "/.config/mcalx" );
      xdgconfigmcalx.append( string(home) + "/.config/" );
      filenamemcalx.append( string(home) + "/.config/mcalx/mcalxrc" );
   } else {
      homemcalx.append( string(xdgconfighome) + "/mcalx" );
      xdgconfigmcalx.append( xdgconfighome );
      filenamemcalx.append( string(xdgconfighome) + "/mcalx/mcalxrc" );
   }

   //uid_t euid = geteuid();
   seteuid(getuid());
   mkdir(xdgconfigmcalx.data(), 0700);    /* Create directories */
   mkdir(homemcalx.data(), 0700);         /* for mcalx */

   return string( filenamemcalx );
}

int write_configfile( datacfg dt ) {
   ofstream out;
   string   fname;

   /* Open file for write */
   fname = set_filename();
   out.open( fname.data(), ios::out );

   if ( out.fail() ) {
      return 1;
   } else {

      out << msgWarning;
      out << "row_MatrixA=" << dt.rowMatrixA << "\n";
      out << "col_MatrixA=" << dt.colMatrixA << "\n";
      out << "precision_A=" << dt.precisionA << "\n";
      out << "row_MatrixB=" << dt.rowMatrixB << "\n";
      out << "col_MatrixB=" << dt.colMatrixB << "\n";
      out << "precision_B=" << dt.precisionB << "\n";
      out << "precision_C=" << dt.precisionC << "\n";
      out << "field_delimeter=" << dt.fdel   << "\n";
      out << "text_delimeter=" << dt.tdel    << "\n";
      out.close();

      return 0;
   }
}

/* Read config file, create if not exist */
datacfg read_configfile  () {
   string   fname;
   ifstream in;
   datacfg  dt = dt_init;

   /* Open file */
   fname = set_filename();
   in.open( fname.data(), ios::in );

   if ( in.fail() ) {
      write_configfile( dt );
   } else {    /* Read configuration */
      char     line[128];
      string   str;

      while( in.getline( line, sizeof(line) ) ) {
         str.assign( line );
         string::size_type begin = str.find_first_not_of(" \f\t\v");
         //Skips blank lines
         if(begin == string::npos) continue;

         //Skips #
         if(string("#").find(str[begin]) != string::npos) continue;

         string key, value;
         try {
            key   = str.substr( 0, str.find("=") );
            value = str.substr( str.find("=") + 1, str.length() );
         } catch(exception& e) {
            key = str.erase(str.find_first_of(" "),str.find_first_not_of(" "));
         }

         /* Check key */
         if(key == "row_MatrixA") {
            dt.rowMatrixA = stoi( value );
            continue;
         }
         if(key == "col_MatrixA") {
            dt.colMatrixA = stoi( value );
            continue;
         }
         if(key == "precision_A") {
            dt.precisionA = stoi( value );
            continue;
         }
         if(key == "row_MatrixB") {
            dt.rowMatrixB = stoi( value );
            continue;
         }
         if(key == "col_MatrixB") {
            dt.colMatrixB = stoi( value );
            continue;
         }
         if(key == "precision_B") {
            dt.precisionB = stoi( value );
            continue;
         }
         if(key == "precision_C") {
            dt.precisionC = stoi( value );
            continue;
         }
         if(key == "field_delimeter") {
            auto s= fd_def.find( stoi( value ) );
            dt.fdel = ( s != fd_def.end() ? s->first : 0 );
            continue;
         }
         if(key == "text_delimeter") {
            auto s= td_def.find( stoi( value ) );
            dt.tdel = ( s != td_def.end() ? s->first : 0 );
            continue;
         }
      }
      in.close();
   }

   return dt;
}

/* Class wPref definition ---- */
wPref::wPref(int W,int H,const char* L=0) :
	Fl_Double_Window(W,H,L)
	{
		int x = 15; 	int y = 25;
		dt_wPref = dt_init;
		
		o1 = new Fl_Box(x, y, 80, 25, "Precision");
		o1->labelfont(1);
		o1->labelsize(12);
		o1->align(Fl_Align(FL_ALIGN_TOP_LEFT));

		x = o1->w() + 10 ; y = o1->h() + 10;
		mA = new Fl_Spinner(x, y, 45, 25, "Matrix A");
		mA->minimum(1);
		mA->maximum(8);
		mA->value(dt_wPref.precisionA);

		x += mA->w() + 70 ;
		mB = new Fl_Spinner(x, y, 45, 25, "Matrix B");
		mB->maximum(8);
		mB->value(dt_wPref.precisionB);
	
		x += mB->w() + 70 ;
		mC = new Fl_Spinner(x, y, 45, 25, "Matrix C");
		mC->maximum(8);
		mC->value(dt_wPref.precisionC);

		x = 15;	y += mC->h();	
		o2 = new Fl_Box(10, 100, 80, 25, "CSV fields");
		o2->labelfont(1);
		o2->labelsize(12);
		o2->align(Fl_Align(FL_ALIGN_TOP_LEFT));

		x = o1->w() + 70 ; y += o2->h() + 25;
		fdel = new Fl_Choice(x, y, 170, 25, "Fields delimeter");
		fdel->down_box(FL_BORDER_BOX);
		fdel->add( fdelimeter );
		fdel->value(dt_wPref.fdel);
	
		y += fdel->h() + 10;
		tdel = new Fl_Choice(x, y, 170, 25, "Text delimeter");
		tdel->down_box(FL_BORDER_BOX);
		tdel->add( tdelimeter );
		tdel->value(dt_wPref.tdel);

		x = 180 ; y += tdel->h() + 30;
		cbutton = new Fl_Button(x, y, 80, 30, "&Cancel");
		x += cbutton->w() + 10;
		rbutton = new Fl_Return_Button(x, y, 80, 30, "&OK");
	
		rbutton->callback(cb_button, (void *) this );
		cbutton->callback(cb_button, (void *) this );

}

/* ----------------- */
wPref::~wPref() { cout << "wPref\n" ;}
/* ----------------- */
void	wPref::setValues2dt() {
	dt_wPref.precisionA = mA->value();
	dt_wPref.precisionB = mB->value();
	dt_wPref.precisionC = mC->value();
	dt_wPref.fdel = fdel->value();
	dt_wPref.tdel = tdel->value();
	return;
}
/* ----------------- */
datacfg wPref::getPref() { return dt_wPref; }
/* ----------------- */
void   wPref::setPref(datacfg v) { 
	dt_wPref = v;
	mA->value( dt_wPref.precisionA );
	mB->value( dt_wPref.precisionB );
	mC->value( dt_wPref.precisionC );
	fdel->value( dt_wPref.fdel );
	tdel->value( dt_wPref.tdel );
	
	return;
}
